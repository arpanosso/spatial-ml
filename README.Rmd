---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Autocorrelação Espacial e Aprendizado de máquina

*Laís de Souza Teixeira & Alan Rodrigo Panosso* 


```{r,message=FALSE,warning=FALSE,error=FALSE}
# devtools::install_github("Envirometrix/plotKML")
# devtools::install_github("Envirometrix/landmap")
library(tidyverse)
library(sp)
library(geobr)
library(skimr)
# library(GSIF)
library(geoR)
library(raster)
```

```{r}
dados <- read_rds("data/dados_lais.rds")
skim(dados)
```

# Seguindo o exemplo de Meuse

```{r}
demo(meuse, echo=FALSE)
data(meuse)
```

## Ajustando o modelo


```{r}
zinc.geo <- as.geodata(meuse[c("x","y","zinc")])
ini.v <- c(var(log1p(zinc.geo$data)),500)
zinc.vgm <- likfit(zinc.geo, lambda=0, ini=ini.v, cov.model=
"exponential")
```


```{r}
data("meuse.grid")
locs <- as.geodata(meuse.grid)$coords
zinc.ok <- krige.conv(zinc.geo, locations=locs, krige=krige.control
(obj.m=zinc.vgm))
```



## Buffer distance
```{r}
# grid.dist0 <- buffer.dist(meuse["zinc"], as.geodata(meuse.grid)[1], as.factor(1:nrow(meuse)))
# 
# classes <- cut(meuse$om, breaks=seq(0, 17, length=8))
# grid.dist <- buffer.dist(meuse["om"], as.geodata(meuse.grid)[1], classes)
# plot(stack(grid.dist))
```













